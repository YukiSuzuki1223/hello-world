ソフトウェア講義１

第1回の講義では、ソフトウェア工学という学問の概要と、この講義を通じて何を学ぶべきかが示された。特に、ソフトウェア開発における「体系的な知識」と「実務的なスキル」の両立の重要性が強調された。
ソフトウェア工学の学習目的として、単なるプログラミング技術の習得ではなく、「品質・コスト・納期」を最適化するための方法論を理解し、応用することが挙げられた。つまり、ソフトウェアを効率的に、かつ持続可能に設計・開発・保守するための知見を得ることが目標である。
また、ソフトウェア工学が難しいとされる理由として、以下の三点が挙げられた。
・実務と知見のギャップ：実際に開発経験がない学生にとって、抽象的な知見だけでは現場をイメージしにくい。
・知見と実践の乖離：理論を理解しても、それを現場で活用するには応用力が求められる。
・チームでの知識共有の必要性：個人の知識では限界があり、チーム全体での連携が不可欠である。
加えて、講師の個人的な経験談が紹介され、実社会におけるソフトウェア工学の重要性が具体的に示された。たとえば、IT未経験からエンジニアとなった事例や、継続的なシステム更新の必要性、FOSS4G（Free Open Source Software for Geospatial）プロジェクトへの関わりなどが挙げられ、ソフトウェア開発が単なる技術活動ではなく、社会的・人的な側面とも密接に関わることがわかった。

また、近年のAIの進展に伴い、LLM（大規模言語モデル）による自動ソフトウェア生成が可能となる時代においても、開発を監督し品質や要件を担保する役割は人間が担う必要があることが述べられた。すなわち、AIに任せられる部分が増えても、ソフトウェア工学の知識を持つエンジニアの役割は今後ますます重要になると考えられる。

ソフトウェア講義２

第2回の講義では、ソフトウェア工学の基本的な定義とその目的、そしてソフトウェア開発における課題と対応の考え方について学んだ。特に印象的だったのは、ソフトウェアというものの本質的な性質と、それに対する工学的アプローチの必要性である。
まず、ソフトウェアとは何かという問いに対し、単にプログラムの集合ではなく、「命令語（プログラム）」「データ構造」「操作マニュアル等の関連情報」からなる総合的な構造物であることが示された。これは、ソフトウェアが情報を扱うシステムであり、動作させるための手順や使い方までもが製品の一部であることを意味する。
また、ハードウェアと異なりソフトウェアは物理的に劣化しないが、環境や技術、ビジネス要件の変化に適応できなくなることで“悪化”するという点が強調された。そのため、ソフトウェアは常に進化し続ける必要があり、その過程を適切に管理・設計するためにソフトウェア工学の知識が不可欠となる。
講義ではIEEEの定義に基づき、ソフトウェア工学は「ソフトウェアの開発、運用、保守に対する体系的、規律的、かつ定量的なアプローチの適用」であると紹介された。単なる開発技術ではなく、プロジェクト全体を管理し、品質・コスト・納期を調整する枠組みとしての役割がある。
加えて、実務におけるソフトウェア開発の進め方について、問題解決の4ステップ（問題の理解・解決策の計画・実装・検証）が提示され、これは今後の演習や実プロジェクトを進める際の基本的な枠組みになると理解した。
さらに、Hookerの提唱する7つの原則が紹介され、以下のような姿勢が求められることを学んだ：
・システムはユーザーに価値を与えるものであることを忘れない
・設計は常にシンプルであるべき（KISS原則）
・明確なビジョンを持ち続ける
・他人に伝わるコード・設計・文書を書く
・未来に対応できるようオープンに設計する
・再利用を計画段階から考える
・行動の前に考える習慣をつける
これらの原則は、単なる技術力だけでなく、開発者としての態度や責任感も重要であることを示しており、将来ソフトウェア開発に関わる者として心に留めておきたいと感じた

ソフトウェア講義３

第3回の講義では、ソフトウェアがどのような過程を経て企画・開発・運用・廃止されるのかという一連の流れ、すなわち「ソフトウェアライフサイクル」について学んだ。
まず、ソフトウェアライフサイクルは以下の三つの主要な段階から構成される。
企画・要件定義フェーズ
　この段階では、ビジネス的・技術的なニーズに基づき、「どのようなソフトウェアが必要か」「それによって業務がどう変わるのか」といった点を明らかにする。要件定義書では、目的や概要、機能、構成、目標性能、インターフェース仕様、運用条件、制限事項、開発スケジュールなどが明文化される。
設計・実装フェーズ
　要件定義書に基づき、システムの構成やモジュール設計が行われ、プログラムとして具現化される。このとき、WBS（Work Breakdown Structure）を用いて作業を分解・整理し、内製か外注か、あるいはオフショア開発かといった手法の選定も行われる。
運用・保守・廃止フェーズ
　稼働中のソフトウェアは、使用状況や発生する問題に応じて修正・改善が施される。また、最終的にはサービス終了やシステム更改を迎えることになる。このとき、運用中に得られたデータや知見を次の開発に生かすことが望ましい。
講義では、「テストとデバッグ」についても詳しく触れられた。完全にバグのないソフトウェアは存在しないという前提に立ち、いかにしてバグの影響を最小限に抑えるかが重要である。工数の制約からすべてをテストすることは困難であり、どの部分をどの程度テストするかを判断するスキルが求められる。
さらに、運用後のソフトウェアは開発者が関与していない場合も多く、適切な**ドキュメンテーション（文書化）**が不可欠であると強調された。特に、海外の企業との連携やオープンソース利用の増加により、英語による文書作成能力も必要となる。

ソフトウェア講義４

第4回の講義では、「プロジェクト」と「ソフトウェア分析」という2つの重要なテーマについて学んだ。
まず、「プロジェクト」とは何かについて定義が示された。プロジェクトは有期性と独自性を持つ活動であり、ソフトウェア開発はその典型的な例とされる。つまり、プロジェクトは「限られた期間の中で、特定の目的を達成するために一度きり行われる業務」であり、継続的なルーチンワークとは異なる。
次に、目標設定と計画のアプローチとして、「フォアキャスティング（forecasting）」と「バックキャスティング（backcasting）」という2つの視点が紹介された。前者は現在の状況から積み上げて将来を予測するものであり、学校の勉強などに適している。一方、後者は最終的な目標から逆算して必要なステップを計画するもので、ソフトウェア開発のようなプロジェクトにはこの考え方が有効である。目標達成を確実にするためには、最初にビジョンを明確に設定し、その実現に必要な行動を段階的に設計する必要がある。
後半では、ソフトウェア分析の基礎について学習した。ここでは、品質（Quality）、コスト（Cost）、納期（Delivery）というQCDの観点からソフトウェアを評価する手法が取り上げられた。特に、以下の4つの分析指標が紹介された。
・コードの物量（ステップ数）：総ソースコード行数によって開発規模を定量化する。
・コードの物量（オブジェクト容量）：主に組み込み系ソフトウェアにおいて、メモリやストレージ制約を評価する。
・ファンクションポイント（FP）法：開発前に要件から規模を見積もる手法。以下の式が用いられる：
　FP値 = 基準値 × (0.65 + 調整値 / 100)
　原価 = FP値 × 単価 × 換算係数
・使い勝手の評価：画面の視認性、操作性、互換性など、ユーザビリティに関する主観的要素の分析。
また、ソフトウェアの品質に関連して「バグ発生率」や「Hyrumの法則」が紹介された。バグ発生率は「バグ件数 ÷ ステップ数」で求められ、品質管理の一指標とされる。一方、Hyrumの法則とは、APIの仕様として明示されていない振る舞いにもユーザーが依存するようになるというものであり、変更の影響範囲が広がりやすいソフトウェアの特性を端的に表している。

ソフトウェア講義５

第5回の講義では、プロジェクト管理において極めて重要な概念であるWBSについて学んだ。
wBSとは、プロジェクトの目標達成に必要な「要素成果物」を起点として、それを実現するための作業を段階的に細分化した構成図である。各作業は「Work」として定義され、全体を「Breakdown（分解）」し、「Structure（構造化）」することによって、何を、誰が、いつまでに行うのかが一目で分かるようになる。
WBSを作成するうえで重要とされたのは、以下のような考え方である：
・トップダウンアプローチ
　まずプロジェクト全体のスコープを明確にしたうえで、そこから大分類（フェーズ）→中分類（タスク群）→小分類（具体的な作業）へと順に分解していく。これはボトムアップではなく、目標から逆算する「バックキャスティング」の発想に基づいている。
・グルーピングと順序関係の整理
　関連する作業は論理的にまとめ、各グループ間の順序関係（例：データ収集 → 分析 → 可視化）を意識することで、作業の流れを明確にする。
・MECE（Mutually Exclusive, Collectively Exhaustive）の原則
　作業を「漏れなく、重複なく」列挙することで、抜けやムダのないWBSを作成する。
さらに、実践的な演習として、学生は「情報工学科の学生によるゲーム大会の企画・運営」を題材にWBSを作成する課題が課された。この中では、「準備」「設営」「本番」「片付け」といったフェーズを設定し、それぞれのタスクを細分化したうえで、3人のメンバー（私、友人A、友人B）に役割をアサインすることが求められた。タスクごとに開始日・終了日を記入し、スケジュールの整合性を取ることも重要である。この演習を通じて、WBSの有効性を実感することができた。特に、プロジェクトを構造的に捉えることで、「何が未決定なのか」「どこにリスクがあるのか」を可視化でき、計画段階での意思決定やリソース配分がより合理的に行えると感じた。

ソフトウェア講義６

この講義の中心は、学生自身がプロジェクトマネージャーとなって仮想プロジェクト（情報工学科の学生交流を目的とした「ゲーム大会」）のWBSを作成するという実践課題である。具体的には、プロジェクトを構成するすべての作業を、準備・当日運営・後片付けなどのフェーズに分け、それぞれを階層的にタスクへと分解していくことが求められた。
作成にあたっての重要な要点は以下の通りである：
・スコープの明確化
　プロジェクトの目的、規模、想定条件（日時・場所・参加人数・使用ゲームの種類など）を初期段階で明文化することが求められた。これはWBSの最上位構造を決定するうえで不可欠である。
・タスクの洗い出しと分類
　例えば、「備品準備」「ルール説明」「司会進行」「景品手配」「サイドイベントの設計」など、各フェーズに必要な作業を細分化し、漏れなく記載することが求められた。また、実行者（自分、友人A、友人B）の役割分担や実施日程も設定し、現実的なスケジュールに落とし込んでいく。
・WBSの構造的整合性と実行可能性
　分解されたタスクは論理的な順序と依存関係を持ち、重複や曖昧さが生じないよう「MECE（Mutually Exclusive, Collectively Exhaustive）」の原則に基づいて整理する必要がある。例えば、設営作業は大会当日より前でなければならず、片付けは最終タスクとなるべきである。
WBS作成を通して得られた最も大きな学びは、「計画段階でいかに具体化できるか」がプロジェクトの成否を分けるという点である。目に見えない作業も明示的に書き出し、責任と期間を明確化することで、作業の漏れ・遅延を未然に防ぐことが可能となる。
